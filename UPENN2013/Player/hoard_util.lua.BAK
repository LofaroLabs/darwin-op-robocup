module(... or '', package.seeall)

-- Get Platform for package path
cwd = '.';
local platform = os.getenv('PLATFORM') or '';
if (string.find(platform,'webots')) then cwd = cwd .. '/Player';
end

-- Get Computer for Lib suffix
local computer = os.getenv('COMPUTER') or '';
if (string.find(computer, 'Darwin')) then
  -- MacOS X uses .dylib:
--  package.cpath = cwd .. '/Lib/?.dylib;' .. package.cpath;
  package.cpath = cwd .. '/Lib/?.so;' .. package.cpath;
else
  package.cpath = cwd .. '/Lib/?.so;' .. package.cpath;
end

package.path = cwd .. '/?.lua;' .. package.path;
package.path = cwd .. '/Util/?.lua;' .. package.path;
package.path = cwd .. '/Config/?.lua;' .. package.path;
package.path = cwd .. '/Lib/?.lua;' .. package.path;
package.path = cwd .. '/Dev/?.lua;' .. package.path;
package.path = cwd .. '/Motion/?.lua;' .. package.path;
package.path = cwd .. '/Motion/keyframes/?.lua;' .. package.path;
package.path = cwd .. '/Motion/Walk/?.lua;' .. package.path;
package.path = cwd .. '/Vision/?.lua;' .. package.path;
package.path = cwd .. '/World/?.lua;' .. package.path;
package.path = cwd .. '/Lib/json4lua-0.9.50/?/?.lua;' .. package.path
require('init')
require('unix')
require('Config')
require('shm')
require('vector')
require('vcm')
require('gcm')
require('wcm')
require('mcm')
require('Speak')
require('getch')
require('Body')
require('Motion')
json = require("json")

gcm.say_id();

darwin = true;

ready = true;
smindex = 0;
initToggle = true;

-- main loop
count = 0;
lcount = 0;
tUpdate = unix.time();
connected = false;
myFunctions = {}



myFunctions["getServos"] = function (args, client)
	print("You found getServos with args " .. args);
	thedata = Body.get_sensor_data();
	table.foreach(thedata, inspect);
	client:send(json.encode(thedata));
	print("Sent the sevo data!")
	print(json.encode(thedata))
end

myFunctions["setServos"] = function (args, client)

	print("You found setServos!!!");
	table.foreach(args, print)
	print(args.index .. " " .. args.current);
	Body.set_servo_command(args.index, math.pi/180*args.current)
end

myFunctions["setServoHardness"] = function (args, client)

	print("you called setServoHardness");
	Body.set_servo_hardness(args.index, args.hardness);

end

co = coroutine.create(function (args, client)
	if(args~=nil) then 
		unix.usleep(args *1E6);
	end
	
	features[1] = wcm.get_pose();
	features[2] = vcm.get_ball_detect();
	features[3] = wcm.get_ball_x();
	features[4] = wcm.get_ball_y();
	client:send(json.encode(features));
	-- Send the features to horde via the client
	-- args may contain the amount of time to wait between sending
	
end )
myFunctions["StartSending"] = function (args, client)
	coroutine.resume(co,args, client);
end

myFunctions["StopSending"] = function (args, client)
	coroutine.yield(co)
end


myFunctions["disconnect"] = function (args, client)
	client:close();
	connected = false;
end


myFunctions["doHordeMotion"] = function(args, client)


	hordeFunctions[args.action](args.args, client);

end

hordeFunctions = {}
hordeFunctions["headMotion"] = function(args, client)
end

hordeFunctions["walkForward"] = function(args,client)
	BodyFSM.sm:set_state('bodyWalkForward');
end

hordeFunctions["approachBall"] = function(args,client)
	BodyFSM.sm:set_state('bodyApproach');
end
hordeFunctions["kickBall"] = function(args,client)
        BodyFSM.sm:set_state('bodyKickGMU');
end
package.path = cwd..'/HeadFSM/'..Config.fsm.head[smindex+1]..'/?.lua;'..package.path;

package.path = cwd..'/BodyFSM/'..Config.fsm.head[smindex+1]..'/?.lua;'..package.path;
require('BodyFSM')
require('HeadFSM')
--HeadFSM.entry();
--HeadFSM.sm:set_state('headStart');
--Body.set_head_hardness(.5); -- required to at least set the hardness in order for motions to work
leftArmMotion = math.pi/180*vector.new({60,30,-30});
--Body.set_larm_hardness({0.5,0.5,0.5});
--Body.set_larm_:command(leftArmMotion);
function inspect(key, value)
	table.foreach(value,print)
end

--table.foreach(Body.get_sensor_data(),inspect)

--my stuff, ugly
count = 0;
updateMotion = coroutine.create(function() 
  count = count +1;
  while (1==1) do 
  	Motion.update();
  	Body.update();
  	BodyFSM.update();
  	if(count==1000) then
	hordeFunctions["approachBall"](nil,nil);
  	end
  	if(count==2000) then
  		hordeFunctions["walkForward"](nil,nil);
  	end
  	if(count==3000) then
 	 	hordeFunctions["kickBall"](nil,nil);
  	end
  	if(count%100==0) then 
  		print("dufus, updating motion, nerd \n");
  	end 
      count = count + 1;
  end
end)
connectionThread = coroutine.create(function ()
        print("got into con thread");
	if( darwin ) then
                local tDelay = 0.005 * 1E6; -- Loop every 5ms


 -- setup the server
                local socket = require("socket")
		print("socket assert");
                local server = assert(socket.bind("*", 40009))
		print("socket accept")
                local client = server:accept()
		print("socket accepted");
                connected = true;
                print("connected")
  


                while connected do
                        --client:settimeout(10)
                        local line, err = client:receive()
                        if not err then
                                print(line);
                                updateAction(line, client);
                        elseif err == "closed" then
                                print(err)
                                connected = false;
                        else
                                print(err)
                        end
    --client:close()
    
                        unix.usleep(tDelay);
                end
        end
end)

function updateAction(servData, client)
  count = count + 1;
  --Update battery info
  wcm.set_robot_battery_level(Body.get_battery_level());
  vcm.set_camera_teambroadcast(1); --Turn on wireless team broadcast
  
	print("In update")
	req = json.decode(servData)

	print("Received action "..req.action);
	myFunctions[req.action](req.args, client)
--  hordeFunctions["walkForward"](nil,nil);  
end

function initMotion()
	BodyFSM.entry();
	Motion.entry();
        unix.usleep(1.00*1E6);

        Body.set_body_hardness(.50);
        Motion.event("standup");
        k = 0;
        while(.005 * k < 5.27) do
                Motion.update();
                Body.update();
                unix.usleep(.005*1E6);
                k=k+1;
        end
	Motion.event("standup");
	unix.usleep(3.0*1E6);
	BodyFSM.sm:set_state('bodyStop')		
	BodyFSM.update();
	
--	BodyFSM.entry();	
end
if(darwin) then 
        print("starting connection thread\n");
	coroutine.resume(connectionThread);
	print("done with connection thread, initing motions\n");
	initMotion();
	print("init motion done, updateMotion");
	coroutine.resume(updateMotion);
	--BodyFSM.entry();
	--Motion.event("walk");
        --walk.start();
	while (1) do	
   		--walk.startMotion("swing");	
		unix.usleep(.005*1E6);
             	--update(nil,nil);
	end
end
--connection drew stuff, seriously i'm ruining this beautiful code

